先看 mysql执行过程png，
1： 总体来说,Mysql可以分为 Server层和存储引擎层两部分
    Server 层包括:  连接器、查询缓存、分析器、优化器、执行器等，涵盖Mysql的大多数核心服务功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨引擎的功能
都在这一层实现，比如存储过程、触发器、视图等.(注意事项,在mysql 8.0的基础上已经把这个功能给砍掉了)

    存储引擎则负责数据的存储与提取。其架构是插件式的，支持InnoDB、MyiSAM、memory等多个存储引擎，现在最常用的存储引擎是Innodb，它从Mysql 5.5版本开始成为默认引擎。
也就是通过create table 建表的时候,如果不指定引擎类型，默认就是innodb，也可以通过指定存储引擎的类型来选择别的引擎，例如: create table 语句中使用 engine = memory来指定使用内存存储引擎
创建表，不同存储引擎的表数据存储方式不同，支持的功能也不同。


2：Server层 不同层次使用方法
    连接器: 
            第一步: 先连接到这个数据库上，连接器负责跟客户端建立连接、获取权限、维持和管理链接，连接命令: mysql -h$ip -P$port -u$user -p$password， 可以用show processlist看到连接状态。 
            补充: 长连接/短链接  长连接: 数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短链接则是指每次执行完很少的几次查询后就断开，下次查询在重新建立一个.
        但是全部使用长连接后，有时候Mysql占用的内存涨的特别快，这是因为mysql在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开后才能释放，如果长连接累计下来，可能导致内存占用
        过大，被系统强行杀掉(OOM), 从现象来看就是Mysql异常重启。也有解决方案, 可以的话还是建议使用连接池:
            1: 定期断开长连接，使用一段时间后，或者在程序里面判断执行一个占用内存后的大查询后，断开连接，之后要查询在重连。
            2: 如果在Mysql5.7以上，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源，这个过程不需要重连和重新做权限校验，但是会将连接恢复到刚刚创建完的状态。

    查询缓存:
            连接建立以后，就可以执行select语句，执行逻辑就会来到第二步: 查询缓存。
            Mysql拿到一个查询请求后，会先查询缓存看看，之前是不是执行过，之前执行的语句以及结果可能会以key_value对的形式，被直接缓存到内存中，key 是查询语句，value是查询结果.
        如果不在查询缓存中，则继续后面的执行阶段，在执行完成后，执行结果会被存入查询缓存中。
            但是不建议使用查询缓存?  因为查询缓存的失效非常频繁，只要有一个表的更新，这个表上所有的缓存都会被清空，会造成缓存命中率特别低的情况，但是也提供了按需使用的方式。
            设置方法  可以把参数query_cache_type 设置成demand，这样默认都不走缓存，确定要使用缓存则  select sql_cache *from T where ID = 10 显示指定

    分析器:
        如果没有命中查询缓存，就要开始执行真正的查询语句，但是首先mysql需要知道你做什么。因此需要对sql语句进行解析，也就是语法分析

    优化器:
        经过分析器之后，mysql知道你要做什么，在开始执行之前，还要经过优化器处理，优化器是在表里面有多个索引的时候，决定使用哪个索引，或者在一个语句多表关联查询的时候，决定各个表的连接顺序。
        for example:
            mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
            方案1 : 先取 t1.c = 10，然后根据id关联到t2，在判断t2.d = 20
            方案2:  先取 t2.d = 20，然后根据id关联到t1,在判断t1.c = 10
        这两种执行方法逻辑一样，但是效率不同，优化器 就是 决定具体使用那种方案.

    执行器:
        mysql> select * from T where ID=10;
        1: 开始执行的时候，需要判断有没有 权限，如果没有，则返回没有权限的错误(在工程实现上，如果命中缓存，会在查询缓存返回结果的时候，做权限校验，查询也会在优化器之前调用precheck验证权限)
        2: 如果有权限，那么打开表的时候，执行器会根据表的引擎取定义，去使用引擎锁提供的接口。
        3：调用引擎接口取"下一行"，判断ID ？= 10，不是则跳过，是则存储在结果集中在结果集中。
        4：继续下一行，循环读取，直到最后一行。
        5: 执行器将上述遍历集所有满足条件的行组成记录集作为结果集返回给客户端。