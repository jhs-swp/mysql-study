1: 为什么会有索引?
    索引的出现是为了提高数据查询的效率，就像书的目录一样

2: 索引有三种常见模型:  哈希表/有序数组/搜索树
    哈希表:
        哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 
    换算成一个确定的位置，然后把 value 放在数组的这个位置。
        但是多个key经过哈希函数的换算，会出现同一个值的情况。处理这种情况的办法就是，拉出一个链表,俗称拉链法。看图解 拉链法 图中，User2 和 User4 根据身份证号算出来的值都是 N，
    但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。
    缺点: 值并不是递增的，因为这样新增会十分快，只需要往后追加就可以，但缺点是，因为不是有序的，所以做区间查询的速度非常慢，所以，哈希表这种比较适合等值查询

    有序数组:
        顺序递增，查找的时候也能2分查找，时间复杂度为 logn, 因为有序，所以也支持范围查找，但是问题就是 更新的时候 就很麻烦，所以插入的时候必须挪动 后面所有的，成本太高了。

    二叉搜索树:
        二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照
     UserA -> UserC -> UserF -> User2 这个路径得到。这个时间复杂度是 O(log(N))。
        但是对于mysql innodb默认引擎b+ 树的实现而言，b+ 树并不一定是二叉树，可能是n+树.

        根据innodb的索引组织架构,根据叶子节点的内容,索引类型可以分别为主键索引/非主键索引.
    主键索引存储的叶子节点是整行数据,在innodb里面,主键索引也被称为聚簇索引.

        非主键索引的叶子节点的内容是 主键的值. 在innodb里面,非主键索引也被称为二级索引.
        基于主键索引和普通索引的查询有什么区别:
            如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；如果语句是 select * from T where k=5，
        即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。也就是说，基于非主键索引的
        查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询.

        重点: 索引维护:
            b+树为了维护索引有序性,在插入数据的时候会进行维护, 如果 在不满足 最大空间的前提下, 则直接插入到最后面,如果满足最大空间,则会相对
        麻烦,在逻辑上挪动后面的数据,空出位置,如果所在数据页全部满了,则会进行页分裂,挪动部分数据过去,性能会收到影响.
            当然,也会有页合并,上面反着来.当相邻页面 删除了数据,利用率很低的话,就会把数据给合并.
        

        自增主键 与 其他业务逻辑做主键的区别:
            1: 自增的插入模型,符合递增插入的场景,每次插入一条新纪录都是一个追加的操作,不会涉及到挪动其他记录,也不会触发叶子节点的分裂.
            2: 由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。
        而又业务逻辑的字段做主键,则往往不容易保证有序插入,这样写的成本相对比较高.

        但是kv场景 就比较适合用业务字段直接做主键 1:只有一个索引 2: 该索引必须是唯一索引.



    
